# n2n-memory 开发方案

[English](./DESIGN.md)

---

## 1. 背景与目标
解决全局 MCP Memory Server 导致的跨项目“记忆污染”与幻觉问题。通过将 AI 的认知碎片直接持久化在项目源码目录下，实现项目级的物理隔离与知识共享。

本项目旨在开发一个高度简约、工具中立、且对版本管理友好的 N2N 记忆服务。

## 2. 核心架构设计

### 2.1 存储逻辑
- **存储位置**: `[项目根目录]/.mcp/memory.json`
- **中立性**: 采用 `.mcp` 命名以脱离特定 AI 助手或 IDE 插件的品牌绑定。
- **物理隔离**: 一个项目一个文件，互不干扰，完全随项目代码同步。

### 2.2 交互规范与安全性
- **严格根目录校验**: 取消向上递归搜索。AI 必须在识别到的项目根目录或工作区顶级目录操作。
- **握手协议 (Handshake)**: 新项目初始化需显式确认 (`confirmNewProjectRoot`)，防止目录污染。
- **双缓冲架构 (Dual-Buffer)**:
    - **热数据 (`context.json`)**: 存储高频更新的状态、任务、下一步计划。
    - **冷数据 (`memory.json`)**: 存储结构化的长效知识图谱（实体与关系）。

## 3. 数据结构与检索

### 3.1 极简数据格式
JSON 内部**不包含**版本号、元数据、作者信息或时间戳。仅保留核心知识图谱数据（Entities & Relations），通过 Git 记录实现版本审计。

### 3.2 Git 友好型保存策略
为确保 `git diff` 可读：
1. **强制排序**: 对 `entities` 和 `relations` 执行字典序排序。
2. **规范缩进**: 统一使用 2 空格缩进。

### 3.3 高效检索机制
- **分页支持 (Limit/Offset)**: 针对超大型图谱，支持分批读取，确保 Token 消耗在可控范围。
- **索引摘要模式**: 可选仅读取实体索引而不加载冗余的观测事实。
- **精确节点检索**: 通过 `open_nodes` 精确获取高价值上下文。

## 4. 开发语言效率分析 (Go vs. Node.js vs. Python)

### 4.1 Node.js (TypeScript) - [默认推荐]
- **效率**: 开发效率极高，官方 SDK 最成熟。
- **性能**: 处理单个项目的 JSON（通常 < 10MB）绰绰有余。
- **分发**: 通过 `npx` 可实现免安装运行。

### 4.2 Go - [极致性能选型]
- **效率**: 运行效率最高，内存占用极低（仅需几 MB）。
- **分发**: 编译为单一二进制文件（Single Binary），部署最干净，适合对 IDE 性能有极致要求的用户。
- **场景**: 若未来需要处理拥有数万个节点的超大型知识图谱，Go 是唯一选择。

### 4.3 Python - [不推荐]
- **缺点**: 环境依赖重，分发困难，对于简单的、非 AI 计算密集的 I/O 任务显得过于沉重。

## 5. 优势总结
- **资产化**: 记忆即源码，可审计、可共享。
- **零漂移**: 物理隔离，杜绝跨项目污染。
- **确定性**: 结构化数据比高性能向量数据库更适合高精度的编码决策场景。
